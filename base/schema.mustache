const _ = require('lodash');
const fs = require('fs');
const deref = require('json-schema-deref-sync');
const r = require('lib/db');

var indexes = {};

const schema = fs.readdirSync('./schemas').reduce((s, file) => {
  const name = file.split('.json')[0];
  s[name] = require('./schemas/'+file);
  return s;
}, {});

const getIndexes = tableName => {
  return r.table(tableName).indexList().run()
    .then(indexes => [tableName, indexes.concat("id")]);
};

// Note: This only adds the .indexed property to the schema's top level
// properties and not any nested properties that it might have
const indexModel = (indexes, properties) => {
  return _.mapValues(properties, (prop, name) => {
    if (_.includes(indexes, name)) prop.indexed = true;
    else prop.indexed = false;
    return prop;
  });
};

const transformSchema = (indexes, schema) => {
  return _.mapValues(schema, (model) => {
    const modelIndexes = indexes[model.pluralName];
    model.properties = indexModel(modelIndexes, model.properties);
    return deref(model);
  });
};

exports.setIndexes = () => {
  return r.tableList().run()
  .then(tables => _.reject(tables, t => t === '_migrations'))
  .then(tables => Promise.all(tables.map(getIndexes)))
  .then(_.zipObject)
  .then(result => indexes = result);
};

exports.getSchema = () => transformSchema(indexes, schema);

