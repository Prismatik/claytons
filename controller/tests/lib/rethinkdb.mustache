const test = require('blue-tape');
const rethinkdb = require('../../lib/rethinkdb');
const r = require('../../lib/db');
const UUID = '8f0834ed-ea58-4be9-8cea-ace9893f9b15';

//.buildQuery
test('Given no params it should return the query unchanged', (t) => {
  const query = r.table('test');
  const result = rethinkdb.buildQuery(query, null, {});

  t.equal(result.toString(), query.toString());
  return t.end();
})

test('Given filters it should return a filtered query', (t) => {
  const query = r.table('test');
  const filters = {name: 'Darth Vader'}
  const result = rethinkdb.buildQuery(query, null, filters);
  const expected = query.filter(filters);

  t.equal(result.toString(), expected.toString());
  return t.end();
})

test('Given an indexed field use the index in the query', (t) => {
  const query = r.table('test');
  const filters = {name: 'Darth Vader'}
  const result = rethinkdb.buildQuery(query, 'name', filters);
  const expected = query.getAll('Darth Vader', {index: 'name'});

  t.equal(result.toString(), expected.toString());
  return t.end();
})

test('Given indexed and non-indexed fields it should use index and filter the rest', (t) => {
  const query = r.table('test');
  const filters = {
    name: 'Darth Vader',
    sith: true
  };
  const result = rethinkdb.buildQuery(query, 'name', filters);
  const expected = query.getAll('Darth Vader', {index: 'name'}).filter({sith: true});

  t.equal(result.toString(), expected.toString());
  return t.end();
})

test('Must use .get(x) if an id and no other params provided', (t) => {
  const query = r.table('test');
  const filters = {id: UUID};
  const result = rethinkdb.buildQuery(query, null, filters);
  const expected = query.get(UUID);

  t.equal(result.toString(), expected.toString());
  return t.end();
})

test('Must use .filter(x) if an id and other params provided', (t) => {
  const query = r.table('test');
  const filters = {id: UUID, name: 'Luke Skywalker'};
  const result = rethinkdb.buildQuery(query, null, filters);
  const expected = query.filter(filters);

  t.equal(result.toString(), expected.toString());
  return t.end();
})

//.addTransformations
test('Given skip in params, must apply this to the query', (t) => {
  const query = r.table('test');
  const params = {skip: 5};
  const result = rethinkdb.addTransformations(query, [], params);

  const expected = query.skip(5);
  t.deepEqual(result.toString(), expected.toString());
  return t.end();
})

test('Given limit in params, must apply this to the query', (t) => {
  const query = r.table('test');
  const params = {limit: 5};
  const result = rethinkdb.addTransformations(query, [], params);

  const expected = query.limit(5);
  t.deepEqual(result.toString(), expected.toString());
  return t.end();
})

test('Given orderBy in params, must apply this to query and default to ascending', (t) => {
  const query = r.table('test');
  const params = {orderBy: "name"};
  const result = rethinkdb.addTransformations(query, [], params);

  const expected = query.orderBy(r.asc("name"));
  t.deepEqual(result.toString(), expected.toString());
  return t.end();
})

test('Given order is provided, must sort accordingly', (t) => {
  const query = r.table('test');
  const params = {orderBy: "name", order: "desc"};
  const result = rethinkdb.addTransformations(query, [], params);

  const expected = query.orderBy(r.desc("name"));
  t.deepEqual(result.toString(), expected.toString());
  return t.end();
})

test('Given orderBy is provided and field is indexed, it must use index', (t) => {
  const query = r.table('test');
  const params = {orderBy: "name"};
  const result = rethinkdb.addTransformations(query, ["orderBy"], params);

  const expected = query.orderBy({index: r.asc("name")});
  t.deepEqual(result.toString(), expected.toString());
  return t.end();
})

test('Given orderBy and order is provided for indexed field, sort order must be used', (t) => {
  const query = r.table('test');
  const params = {orderBy: "name", order: "desc"};
  const result = rethinkdb.addTransformations(query, ["orderBy"], params);

  const expected = query.orderBy({index: r.desc("name")});
  t.deepEqual(result.toString(), expected.toString());
  return t.end();
})
