const _ = require('lodash');
const httpError = require('standard-http-error');
const uuid = require('uuid');
const r = require('../lib/db');
const controller = require('../lib/controller');
const rethinkdb = require('../lib/rethinkdb');
const schema = require('../lib/schema');
const warnings = require('../constants/warnings');
{{#isUser}}
const jwt = require('../lib/jwt');
const password = require('simple-password');
{{/isUser}}

const appSchema = require('../schema').getSchema();
const modelSchema = appSchema.{{name}};

module.exports = {
  get: (params) => {
    params = _.assign({ result: true }, controller.normaliseParams(params));
    const queryParams = schema.filter('{{name}}', params);

    const table = r.table('{{pluralName}}');
    const indexes = controller.getIndexes(modelSchema, queryParams);
    const indexBy = _.contains(indexes, 'id') ? 'id' : indexes[0];

    const query = rethinkdb.buildQuery(table, indexBy, queryParams);
    const tranformedQuery = rethinkdb.addTransformations(query, indexes, params);

    const taggedQueries = [
      { tag: 'result', q: tranformedQuery },
      { tag: 'count', q: query.count() }
    ].filter(x => params[x.tag]);

    return Promise.all(taggedQueries.map(x => x.q.run()))
    .then(results => {
      return results.reduce((response, result, i) => {
        const tag = taggedQueries[i].tag;
        response[tag] = result;
        if (tag === 'count' && result > 0) response.found = true;
        if (tag === 'response' && result.length > 0) response.found = true;
        return response;
      }, { found: false });
    });
  },
  watch: (params) => {
    params = controller.normaliseParams(params);
    const queryParams = schema.filter('{{name}}', params);

    const changes = { includeInitial: true, includeStates: true };
    const table = r.table('{{pluralName}}');
    const indexes = controller.getIndexes(modelSchema, queryParams);
    const indexBy = _.contains(indexes, 'id') ? 'id' : indexes[0];

    let query = rethinkdb.buildQuery(table, indexBy, queryParams);
    query = rethinkdb.addTransformations(query, indexes, params);

    if (!rethinkdb.isChangeFeedable(query)) {
      console.log(warnings.RESTRICTED_FEED);
      query = table.getAll(r.args(query.getField('id').coerceTo('array')));
    }

    return query.changes(changes).run();
  },
  {{^isUser}}
  create: ({{name}}) => {
    const valid = schema.validate({{name}});
    if (!valid) throw new httpError('UNPROCESSABLE_ENTITY');
    {{name}}.rev = uuid.v4();
    return r.table('{{pluralName}}')
    .insert({{name}}, { returnChanges: true }).run()
    .then(rethinkdb.firstChange);
  },
  update: ({{name}}) => {
    if (!{{name}}.rev) {
      return Promise.reject(new httpError('BAD_REQUEST', 'No rev provided'));
    }
    const valid = schema.validate({{name}});
    if (!valid) throw new httpError('UNPROCESSABLE_ENTITY');
    return r.table('{{pluralName}}')
    .get({{name}}.id)
    .update(
      rethinkdb.ifRevMatches({{name}}),
      { returnChanges: true }
    )
    .run()
    .then(rethinkdb.checkRevError)
    .then(rethinkdb.firstChange);
  },
  {{/isUser}}
  {{#isUser}}
  create: ({{name}}) => {
    return password.create({{name}}.password, 10)
    .then(hash => {
      const data = _.merge({{name}}, { password: hash });
      const valid = schema.validate(data);
      if (!valid) throw new httpError('UNPROCESSABLE_ENTITY');
      {{name}}.rev = uuid.v4();
      return r.table('{{pluralName}}')
      .insert(data, { returnChanges: true }).run()
      .then(rethinkdb.firstChange);
    });
  },
  update: ({{name}}) => {
    if (!{{name}}.rev) {
      return Promise.reject(new httpError('BAD_REQUEST', 'No rev provided'));
    }
    let getHash;
    if ({{name}}.password) {
      getHash = password.create({{name}}.password, 10);
    } else getHash = Promise.resolve();

    return getHash.then(pass => {
      if (pass) {{name}}.password = pass;
      const valid = schema.validate({{name}});
      if (!valid) throw new httpError('UNPROCESSABLE_ENTITY');
      return r.table('{{pluralName}}')
      .get({{name}}.id)
      .update(
        rethinkdb.ifRevMatches({{name}}),
        { returnChanges: true }
      )
      .run()
      .then(rethinkdb.checkRevError)
      .then(rethinkdb.firstChange);
    });
  },
  {{/isUser}}
  delete: (id) => {
    return r.table('{{pluralName}}').get(id)
    .delete({ returnChanges: true }).run()
    .then(res => {
      return res;
    })
    .then(rethinkdb.firstChange);
  {{#isUser}}
  },
  signin: (email, pass) => {
    const table = r.table('{{pluralName}}');
    const params = { email };
    const indexes = controller.getIndexes(modelSchema, params);
    const indexBy = _.contains(indexes, 'email') ? 'email' : null;

    const query = rethinkdb.buildQuery(table, indexBy, params);

    return query.run()
    .then(users => {
      if (users.length === 0) throw new httpError('UNAUTHORIZED');
      const user = users[0];
      return password.verify(pass, user.password)
      .then(verified => {
        if (verified) return jwt.sign({ id: user.id, role: user.role });
        throw new httpError('UNAUTHORIZED');
      })
      .then(token => {
        return {
          found: true,
          result: { token, user: _.omit(user, 'password') }
        };
      });
    });
  {{/isUser}}
  }
};
