const _ = require('lodash');
const r = require('../lib/db');
const controller = require('../lib/controller');
const rethinkdb = require('../lib/rethinkdb');
const schema = require('../lib/schema');

const appSchema = require('../schema').getSchema();
const modelSchema = appSchema['{{name}}'];

// TODO - filter using schema properties?
const NOT_FILTERS = ['count', 'result', 'order', 'orderBy', 'skip', 'limit'];

const buildQuery = (table, params) => {
  params = _.omit(params, NOT_FILTERS);

  //if only id passed, run query using .get(x)
  if (params.id && Object.keys(params).length === 1)
    return table.get(params.id)

  // NOTE: this only utilises the first indexed field that is found, the
  // remainder are simply passed to filter
  const fields = Object.keys(params);
  const indexedField = fields.filter(f => {
    const match = modelSchema.properties[f] || {}
    return match.indexed;
  })[0]

  if (indexedField != null) {
    table = table.getAll(params[indexedField], {index: indexedField})
    delete params[indexedField]
  }
  
  if (!_.isEmpty(params)) table = table.filter(params)
  return table
}

module.exports = {
  get: (params) => {
    params = _.assign({result: true}, controller.normaliseParams(params));
 
    const table = r.table('{{pluralName}}');
    const query = buildQuery(table, params);
    const resultsQuery = rethinkdb.addTransformations(query, params)

    const taggedQueries = [
      {tag: 'result', q: resultsQuery},
      {tag: 'count', q: query.count()}
    ].filter(x => params[x.tag]);

    return Promise.all(taggedQueries.map(x => x.q.run()))
    .then(results => {
      return results.reduce((response, result, i) => {
        const tag = taggedQueries[i].tag;
        response[tag] = result;
        if (tag === 'count' && result > 0) response.found = true;
        if (tag === 'response' && result.length > 0) response.found = true;
        return response;
      }, {found: false});
    });
  },
  watch: (params) => {
    const table = r.table('{{pluralName}}');

    if (params.id) {
      return table.get(params.id).changes({includeInitial: true, includeStates: true}).run();
    }

    params = _.assign({order: 'asc'}, controller.normaliseParams(params));

    const filteredTable = table.filter(schema.filter('{{name}}', params));
    const query = rethinkdb.addTransformations(filteredTable, params);

    return table.getAll(r.args(query.getField('id').coerceTo('array'))).changes({includeInitial: true, includeStates: true}).run();
  },
  create: ({{name}}) => {
    const valid = schema.validate({{name}});
    if (!valid) return Promise.reject(valid);
    return r.table('{{pluralName}}').insert({{name}}, {returnChanges: true}).run()
    .then(rethinkdb.firstChange);
  },
  update: ({{name}}) => {
    const valid = schema.validate({{name}});
    if (!valid) return Promise.reject(valid);
    return r.table('{{pluralName}}').update({{name}}, {returnChanges: true}).run()
    .then(rethinkdb.firstChange);
  },
  delete: (id) => {
    return r.table('{{pluralName}}').get(id).delete({returnChanges: true}).run()
    .then(res => {
      return res;
    })
    .then(rethinkdb.firstChange);
  }
};
