const test = require('blue-tape');
const fetch = require('node-fetch');
const _ = require('lodash');
const fixture = require('../../fixtures/{{name}}');
const IO = require('socket.io-client');
{{#relationships}}
const {{name}}Fixture = require('../../fixtures/{{name}}');
{{/relationships}}

const assertOk = (t) => {
  return (res) => {
    return t.ok(res.ok, 'statusCode is 2xx');
  }
};

const unwrapJSON = (res) => {
  return res.json()
  .then(json => json.result);
}

const unwrapOldVal = (res) => {
  return res.json()
  .then(json => json.old_val);
}

const getJSON = (suffix) => {
  return fetch(url+suffix)
  .then(unwrapJSON);
}

const url = 'http://localhost:'+process.env.PORT;

const sender = method => suffix => data => {
  return fetch(url+suffix, {
    method: method,
    headers: {
      'Accept': 'application/json',
      'Content-Type': 'application/json'
    },
    body: JSON.stringify( data )
  });
};

const poster = sender('post');
const putter = sender('put');

const deleter = suffix => () => {
  return fetch(url+suffix, {
    method: 'delete',
    headers: {
      'Accept': 'application/json',
    }
  });
};

const {{name}}Poster = poster('/{{pluralName}}')

const {{name}}Creator = times => {
  return Promise.all(_.times(times, () => {
    const data = fixture.valid();
    return {{name}}Poster(data)
    .then(unwrapJSON)
  }));
};

const pop = data => data[0];

const single{{name}}Creator = () => {{name}}Creator(1).then(pop);

test('POSTing a valid sprint should return 200', (t) => {
  const {{name}} = fixture.valid();
  return {{name}}Poster({{name}})
  .then(assertOk(t));
});

test('GET /{{pluralName}}/:id should return 200', (t) => {
  return single{{name}}Creator()
  .then(body => fetch(url+'/{{pluralName}}/'+body.id))
  .then(assertOk(t));
});

test('GET /{{pluralName}} should return 200', (t) => {
  return single{{name}}Creator()
  .then(() => fetch(url+'/{{pluralName}}'))
  .then(assertOk(t));
});

test('GET /{{pluralName}} should return an object with a .result property', (t) => {
  return single{{name}}Creator()
  .then(() => fetch(url+'/{{pluralName}}'))
  .then(res => res.json())
  .then(json => {
    t.equal(typeof json, 'object');
    t.ok(json.result);
  });
});

test('GET /{{pluralName}} should accept search params in the querystring', (t) => {
  return {{name}}Creator(2)
  .then({{pluralName}} => {
    const target = Object.keys({{pluralName}}[0]).filter(k => k != 'id')[0];
    return getJSON('/{{pluralName}}?'+target+'='+{{pluralName}}[0][target])
    .then(json => {
      t.equal(json.length, 1);
      t.equal(json[0][target], {{pluralName}}[0][target]);
    });
  });
});

test('GET /{{pluralName}} should not match non-property search params in the querystring', (t) => {
  return {{name}}Creator(2)
  .then({{pluralName}} => {
    return getJSON('/{{pluralName}}?foo='+{{pluralName}}[0].id)
    .then(json => {
      t.ok(json.length > 1);
    });
  });
});

test('GET /{{pluralName}} should return an array', (t) => {
  return single{{name}}Creator()
  .then(() => getJSON('/{{pluralName}}'))
  .then(json => {
    t.ok(Array.isArray(json));
  });
});

test('GET /{{pluralName}} should paginate if asked', (t) => {
  return {{name}}Creator(5)
  .then(() => getJSON('/{{pluralName}}?limit=2'))
  .then(json => {
    t.equal(json.length, 2);
  });
});

test('GET /{{pluralName}} should skip if asked', (t) => {
  return {{name}}Creator(5)
  .then(() => getJSON('/{{pluralName}}?limit=2'))
  .then(first => {
    t.equal(first.length, 2);
    return getJSON('/{{pluralName}}?limit=2&skip=2')
    .then(second => {
      t.equal(second.length, 2);
      t.notDeepEqual(first, second);
    });
  });
});

test('GET /{{pluralName}} should orderBy if asked', (t) => {
  return {{name}}Creator(15)
  .then(() => getJSON('/{{pluralName}}?orderBy=id'))
  .then(results => {
    const reordered = _.clone(results).sort((a, b) => {
      if (a.id > b.id) return 1;
      if (a.id < b.id) return -1;
      return 0;
    });
    t.deepEqual(_.pluck(reordered, 'id'), _.pluck(results, 'id'));
  });
});

test('GET /{{pluralName}} should orderBy asc if asked', (t) => {
  return {{name}}Creator(15)
  .then(() => getJSON('/{{pluralName}}?orderBy=id&order=asc'))
  .then(results => {
    const reordered = _.clone(results).sort((a, b) => {
      if (a.id > b.id) return 1;
      if (a.id < b.id) return -1;
      return 0;
    });
    t.deepEqual(_.pluck(reordered, 'id'), _.pluck(results, 'id'));
  });
});

test('GET /{{pluralName}} should orderBy desc if asked', (t) => {
  return {{name}}Creator(15)
  .then(() => getJSON('/{{pluralName}}?orderBy=id&order=desc'))
  .then(results => {
    const reordered = _.clone(results).sort((a, b) => {
      if (a.id < b.id) return 1;
      if (a.id > b.id) return -1;
      return 0;
    });
    t.deepEqual(_.pluck(reordered, 'id'), _.pluck(results, 'id'));
  });
});

test('GET /{{pluralName}}?count=true&limit=n should return n matching docs with a count of all matching docs ', (t) => {
  return {{name}}Creator(10)
  .then(() => fetch(url+'/{{pluralName}}?count=true&limit=5'))
  .then(res => res.json())
  .then(json => {
    t.equal(json.result.length, 5);
    t.ok(json.count);
    t.ok(json.count > 5);
  });
});

test('GET /{{pluralName}}?limit=n should return n matching docs without a count of all matching docs ', (t) => {
  return {{name}}Creator(10)
  .then(() => fetch(url+'/{{pluralName}}?limit=5'))
  .then(res => res.json())
  .then(json => {
    t.equal(json.result.length, 5);
    t.ok(!json.count);
  });
});

test('GET /{{pluralName}}?count=true&result=false should return only a count with no matching docs', (t) => {
  return {{name}}Creator(10)
  .then(() => fetch(url+'/{{pluralName}}?count=true&result=false'))
  .then(res => res.json())
  .then(json => {
    t.ok(!json.result, 'has no result');
    t.ok(json.count, 'has a count');
    t.ok(json.count > 5, 'count is greater than 5');
  });
});


test('POSTing a valid {{name}} should actually persist it', (t) => {
  return single{{name}}Creator()
  .then(spec => {
    return getJSON('/{{pluralName}}/'+spec.id)
    .then((json) => {
      t.equal(json.id, spec.id);
    });
  });
});

test('PUTing an updated {{name}} should actually persist it', (t) => {
  return single{{name}}Creator()
  .then(body => {
    body.name = 'Something else';
    return body
  })
  .then(body => putter('/{{pluralName}}/'+body.id)(body))
  .then(unwrapJSON)
  .then(body => getJSON('/{{pluralName}}/'+body.id))
  .then((json) => {
    t.equal(json.name, 'Something else');
  });
});

test('DELETEing a {{name}} should return 200', (t) => {
  return single{{name}}Creator()
  .then(body => deleter('/{{pluralName}}/'+body.id)())
  .then(assertOk(t));
});

test('DELETEing a {{name}} should actually delete it', (t) => {
  return single{{name}}Creator()
  .then(body => deleter('/{{pluralName}}/'+body.id)())
  .then(unwrapOldVal)
  .then(body => fetch(url+'/{{pluralName}}/'+body.id))
  .then(res => {
    t.equal(res.status, 404);
  });
});

test('opening a websocket connection to a {{name}} should return it', (t) => {
  return single{{name}}Creator()
  .then(body => {
    return new Promise(resolve => {
      const io = IO(url+'/{{pluralName}}', {query: 'id='+body.id, forceNew: true});
      io.on('record', data => {
        resolve(data.new_val);
        io.disconnect();
      });
    })
    .then(data => {
      t.deepEqual(data, body);
    });
  });
});

test('opening a websocket connection to {{pluralName}} should return all of them', (t) => {
  return {{name}}Creator(2)
  .then(body => {
    return new Promise(resolve => {
      const io = IO(url+'/{{pluralName}}', {forceNew: true});
      var count = 0;
      io.on('record', () => {
        count++;
        if (count > 1) {
          resolve();
          io.disconnect();
        }
      });
    });
  });
});

test('opening a websocket connection to {{pluralName}} should return changed documents', (t) => {
  return single{{name}}Creator()
  .then(body => {
    return new Promise(resolve => {
      const io = IO(url+'/{{pluralName}}', {forceNew: true});
      io.on('state', data => {
        if (data.state === 'ready') {
          const target = _.assign({}, body, {name: 'ohai'});
          io.on('record', data => {
            t.deepEqual(data.new_val, target);
            t.notDeepEqual(data.new_val, body);
            io.disconnect();
            resolve();
          });
          putter('/{{pluralName}}/'+body.id)(target)
        };
      });
    });
  });
});

test('websockets should accept the same filter params as GET requests', (t) => {
  return {{name}}Creator(2)
  .then({{pluralName}} => {
    const target = {{pluralName}}[0];
    const targetKey = Object.keys(target).filter(k => k !== 'id')[0];
    return new Promise(resolve => {
      const query = [targetKey].reduce((r, k) => {
        r[k] = target[k];
        return r;
      }, {});
      const io = IO(url+'/{{pluralName}}', {query: query, forceNew: true});
      io.on('record', data => {
        t.deepEqual(data.new_val, target);
      });
      io.on('state', data => {
        if (data.state != 'ready') return;
        io.disconnect();
        return resolve();
      });
    });
  });
});

test('websockets should accept the same limit param as GET requests', (t) => {
  return {{name}}Creator(2)
  .then(() => {
    return new Promise(resolve => {
      const io = IO(url+'/{{pluralName}}', {query: {limit: 1}, forceNew: true});
      var count = 0;
      io.on('record', data => {
        count++;
      });
      io.on('state', data => {
        if (data.state != 'ready') return;
        io.disconnect();
        t.equal(count, 1);
        return resolve();
      });
    });
  });
});

test('websockets should skip if asked', (t) => {
  return {{name}}Creator(5)
  .then(() => {
    return new Promise(resolve => {
      const io = IO(url+'/{{pluralName}}', {query: {limit: 1}, forceNew: true});
      var first;
      io.on('record', data => {
        first = data;
        io.disconnect();
        const io2 = IO(url+'/{{pluralName}}', {query: {skip: 1}, forceNew: true});
        io2.on('record', data => {
          t.notDeepEqual(data, first);
          io2.disconnect();
          return resolve();
        });
      });
    });
  });
});

test('websockets should orderBy asc if asked', (t) => {
  // The websocket API won't return its results in order, but they will be pulled from the right part of the database
  return {{name}}Creator(15)
  .then(() => {
    return new Promise(resolve => {
      const io = IO(url+'/{{pluralName}}', {query: {orderBy: 'id', order: 'asc'}, forceNew: true});
      const results = [];
      io.on('record', data => {
        results.push(data.new_val);
      });
      io.on('state', data => {
        if (data.state !== 'ready') return;
        io.disconnect();
        const reordered = _.clone(results).sort((a, b) => {
          if (a.id > b.id) return 1;
          if (a.id < b.id) return -1;
          return 0;
        });
        return resolve(getJSON('/{{pluralName}}?orderBy=id&order=asc')
        .then(json => {
          t.deepEqual(_.pluck(reordered, 'id'), _.pluck(json, 'id'));
        }));
      });
    });
  });
});

test('websockets should orderBy desc if asked', (t) => {
  return {{name}}Creator(15)
  .then(() => {
    return new Promise(resolve => {
      const io = IO(url+'/{{pluralName}}', {query: {orderBy: 'id', order: 'desc'}, forceNew: true});
      const results = [];
      io.on('record', data => {
        results.push(data.new_val);
      });
      io.on('state', data => {
        if (data.state !== 'ready') return;
        io.disconnect();
        const reordered = _.clone(results).sort((a, b) => {
          if (a.id < b.id) return 1;
          if (a.id > b.id) return -1;
          return 0;
        });
        return resolve(getJSON('/{{pluralName}}?orderBy=id&order=desc')
        .then(json => {
          t.deepEqual(_.pluck(reordered, 'id'), _.pluck(json, 'id'));
        }));
      });
    });
  });
});
{{#relationships}}

const {{name}}Poster = poster('/{{pluralName}}')

const {{name}}Creator = times => {
  return Promise.all(_.times(times, () => {
    const data = {{name}}Fixture.valid();
    return {{name}}Poster(data)
    .then(unwrapJSON)
  }));
};

const single{{name}}Creator = () => {{name}}Creator(1).then(pop);

test('related entity must exist (can GET using :id)', (t) => {
	return single{{name}}Creator()
	.then(body => fetch(url+'/{{pluralName}}/'+body.id))
	.then(assertOk(t));
});{{^isLast}}\n{{/isLast}}
{{/relationships}}
