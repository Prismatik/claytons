const httpError = require('standard-http-error');
const uuid = require('uuid');
const r = require('../lib/db');
const rethinkdb = require('../lib/rethinkdb');
const schema = require('../lib/schema');
{{#isUser}}
const _ = require('lodash');
const errors = require('../constants/errors');
const password = require('simple-password');
const HASH_ROUNDS = parseInt(process.env.HASH_ROUNDS, 10);
{{/isUser}}

const validate = schema.getValidator('{{camelCase}}');

module.exports = {
  get: (initialParams) => {
    const { query, indexes, params } = rethinkdb.queryBuilder('{{snakeCasePlural}}', '{{camelCase}}', initialParams);
    const transformedQuery = rethinkdb.addTransformations(query, indexes, params);

    return rethinkdb.queryWithCount(query, transformedQuery, params);
  },

  watch: (initialParams) => {
    const { query: initialQuery, indexes, params } = rethinkdb.queryBuilder('{{snakeCasePlural}}', '{{camelCase}}', initialParams);
    let query = initialQuery;

    query = rethinkdb.addTransformations(query, indexes, params);

    const ret = rethinkdb.changeFeed(query, '{{snakeCasePlural}}');

    return Promise.resolve({
      warns: ret.warns,
      query: ret.query.run()
    });
  },
  {{^isUser}}
  create: ({{camelCase}}) => {
    const valid = validate({{camelCase}});
    if (!valid) return Promise.reject(new httpError('UNPROCESSABLE_ENTITY'));
    {{camelCase}}.rev = uuid.v4();
    return r.table('{{snakeCasePlural}}').insert({{camelCase}}, { returnChanges: true }).run()
    .then(rethinkdb.firstChange);
  },
  update: ({{camelCase}}) => {
    if (!{{camelCase}}.rev) {
      return Promise.reject(new httpError('BAD_REQUEST', 'No rev provided'));
    }

    const valid = validate({{camelCase}});
    if (!valid) return Promise.reject(new httpError('UNPROCESSABLE_ENTITY'));

    return r.table('{{snakeCasePlural}}')
    .get({{camelCase}}.id)
    .update(rethinkdb.ifRevMatches({{camelCase}}), { returnChanges: true })
    .run()
    .then(rethinkdb.checkRevError)
    .then(rethinkdb.firstChange);
  },
  {{/isUser}}
  {{#isUser}}
  create: ({{camelCase}}) => {
    if (!{{camelCase}}.password) return Promise.reject(new httpError(422, errors.NO_PASSWORD));
    return password.create({{camelCase}}.password, HASH_ROUNDS)
    .then(hash => {
      const data = _.merge({{camelCase}}, { password: hash });
      const valid = validate({{camelCase}});
      if (!valid) throw new httpError('UNPROCESSABLE_ENTITY');
      {{camelCase}}.rev = uuid.v4();
      return r.table('{{snakeCasePlural}}').insert(data, { returnChanges: true }).run()
      .then(rethinkdb.firstChange);
    });
  },
  update: ({{camelCase}}) => {
    if (!{{camelCase}}.rev) {
      return Promise.reject(new httpError('BAD_REQUEST', 'No rev provided'));
    }
    let getHash;
    if ({{camelCase}}.password) getHash = password.create({{camelCase}}.password, HASH_ROUNDS);
    else getHash = Promise.resolve();

    return getHash.then(pass => {
      if (pass) {{camelCase}}.password = pass;

      return r.table('{{snakeCasePlural}}').get({{camelCase}}.id).run()
      .then(current => {
        const updated = Object.assign({}, current, {{camelCase}});
        const valid = validate(updated);
        if (!valid) throw new httpError('UNPROCESSABLE_ENTITY');

        return r.table('{{snakeCasePlural}}')
        .get({{camelCase}}.id)
        .update(
          rethinkdb.ifRevMatches({{camelCase}}),
          { returnChanges: true }
        )
        .run()
        .then(rethinkdb.checkRevError)
        .then(rethinkdb.firstChange);
      });
    });
  },
  {{/isUser}}
  delete: (id) => {
    return r.table('{{snakeCasePlural}}').get(id).delete({ returnChanges: true }).run()
    .then(res => {
      return res;
    })
    .then(rethinkdb.firstChange);
  }
};
