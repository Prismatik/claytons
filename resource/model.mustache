const httpError = require('standard-http-error');
const uuid = require('uuid');
const r = require('../lib/db');
const rethinkdb = require('../lib/rethinkdb');
const schema = require('../lib/schema');
{{#isUser}}
const _ = require('lodash');
const errors = require('../constants/errors');
const jwt = require('../lib/jwt');
const password = require('simple-password');
const HASH_ROUNDS = parseInt(process.env.HASH_ROUNDS, 10);
{{/isUser}}

const validate = schema.getValidator('{{camelCase}}');

module.exports = {
  get: (initialParams) => {
    const { query, indexes, params } = rethinkdb.queryBuilder('{{snakeCasePlural}}', '{{camelCase}}', initialParams);
    const tranformedQuery = rethinkdb.addTransformations(query, indexes, params);

    const taggedQueries = [
      { tag: 'result', q: tranformedQuery },
      { tag: 'count', q: query.count() }
    ].filter(x => params[x.tag]);

    return Promise.all(taggedQueries.map(x => x.q.run()))
    .then(results => {
      return results.reduce((response, result, i) => {
        const tag = taggedQueries[i].tag;
        response[tag] = result;
        if (tag === 'count' && result > 0) response.found = true;
        if (tag === 'response' && result.length > 0) response.found = true;
        return response;
      }, { found: false });
    });
  },
  watch: (initialParams) => {
    const { query: initialQuery, indexes, params } = rethinkdb.queryBuilder('{{snakeCasePlural}}', '{{camelCase}}', initialParams);
    let query = initialQuery;

    query = rethinkdb.addTransformations(query, indexes, params);

    const ret = rethinkdb.changeFeed(query, '{{snakeCasePlural}}');

    return Promise.resolve({
      warns: ret.warns,
      query: ret.query.run()
    });
  },
  {{^isUser}}
  create: ({{camelCase}}) => {
    const valid = validate({{camelCase}});
    if (!valid) return Promise.reject(new httpError('UNPROCESSABLE_ENTITY'));
    {{camelCase}}.rev = uuid.v4();
    return r.table('{{snakeCasePlural}}').insert({{camelCase}}, { returnChanges: true }).run()
    .then(rethinkdb.firstChange);
  },
  update: ({{camelCase}}) => {
    if (!{{camelCase}}.rev) {
      return Promise.reject(new httpError('BAD_REQUEST', 'No rev provided'));
    }

    const valid = validate({{camelCase}});
    if (!valid) return Promise.reject(new httpError('UNPROCESSABLE_ENTITY'));

    return r.table('{{snakeCasePlural}}')
    .get({{camelCase}}.id)
    .update(rethinkdb.ifRevMatches({{camelCase}}), { returnChanges: true })
    .run()
    .then(rethinkdb.checkRevError)
    .then(rethinkdb.firstChange);
  },
  {{/isUser}}
  {{#isUser}}
  create: ({{camelCase}}) => {
    if (!{{camelCase}}.password) return Promise.reject(new httpError(422, errors.NO_PASSWORD));
    return password.create({{camelCase}}.password, HASH_ROUNDS)
    .then(hash => {
      const data = _.merge({{camelCase}}, { password: hash });
      const valid = validate({{camelCase}});
      if (!valid) throw new httpError('UNPROCESSABLE_ENTITY');
      {{camelCase}}.rev = uuid.v4();
      return r.table('{{snakeCasePlural}}').insert(data, { returnChanges: true }).run()
      .then(rethinkdb.firstChange);
    });
  },
  update: ({{camelCase}}) => {
    if (!{{camelCase}}.rev) {
      return Promise.reject(new httpError('BAD_REQUEST', 'No rev provided'));
    }
    let getHash;
    if ({{camelCase}}.password) getHash = password.create({{camelCase}}.password, HASH_ROUNDS);
    else getHash = Promise.resolve();

    return getHash.then(pass => {
      if (pass) {{camelCase}}.password = pass;

      return r.table('{{snakeCasePlural}}').get({{camelCase}}.id).run()
      .then(current => {
        const updated = Object.assign({}, current, {{camelCase}});
        const valid = validate(updated);
        if (!valid) throw new httpError('UNPROCESSABLE_ENTITY');

        return r.table('{{snakeCasePlural}}')
        .get({{camelCase}}.id)
        .update(
          rethinkdb.ifRevMatches({{camelCase}}),
          { returnChanges: true }
        )
        .run()
        .then(rethinkdb.checkRevError)
        .then(rethinkdb.firstChange);
      });
    });
  },
  {{/isUser}}
  delete: (id) => {
    return r.table('{{snakeCasePlural}}').get(id).delete({ returnChanges: true }).run()
    .then(res => {
      return res;
    })
    .then(rethinkdb.firstChange);
  {{#isUser}}
  },
  signin: (email, pass) => {
    const params = { email };

    const { query } = rethinkdb.queryBuilder('{{snakeCasePlural}}', '{{camelCase}}', params);

    return query.run()
    .then(users => {
      if (users.length === 0) throw new httpError('UNAUTHORIZED');
      const user = users[0];
      return password.verify(pass, user.password)
      .then(verified => {
        if (verified) return jwt.sign({ id: user.id, role: user.role });
        throw new httpError('UNAUTHORIZED');
      })
      .then(token => {
        return {
          found: true,
          result: { token, user: _.omit(user, 'password') }
        };
      });
    });
  {{/isUser}}
  }
};
