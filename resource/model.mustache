const httpError = require('standard-http-error');
const uuid = require('uuid');
const r = require('../lib/db');
const rethinkdb = require('../lib/rethinkdb');
const schema = require('../lib/schema');

const validate = schema.getValidator('{{camelCase}}');

module.exports = {
  get: (initialParams) => {
    const { query, indexes, params } = rethinkdb.queryBuilder('{{snakeCasePlural}}', '{{camelCase}}', initialParams);
    const transformedQuery = rethinkdb.addTransformations(query, indexes, params);

    return rethinkdb.queryWithCount(query, transformedQuery, params);
  },

  watch: (initialParams) => {
    const { query: initialQuery, indexes, params } = rethinkdb.queryBuilder('{{snakeCasePlural}}', '{{camelCase}}', initialParams);
    let query = initialQuery;

    query = rethinkdb.addTransformations(query, indexes, params);

    const ret = rethinkdb.changeFeed(query, '{{snakeCasePlural}}');

    return Promise.resolve({
      warns: ret.warns,
      query: ret.query.run()
    });
  },
  create: ({{camelCase}}) => {
    const valid = validate({{camelCase}});
    if (!valid) return Promise.reject(new httpError('UNPROCESSABLE_ENTITY'));
    {{camelCase}}.rev = uuid.v4();
    return r.table('{{snakeCasePlural}}').insert({{camelCase}}, { returnChanges: true }).run()
    .then(rethinkdb.firstChange);
  },
  update: ({{camelCase}}) => {
    if (!{{camelCase}}.rev) {
      return Promise.reject(new httpError('BAD_REQUEST', 'No rev provided'));
    }

    const valid = validate({{camelCase}});
    if (!valid) return Promise.reject(new httpError('UNPROCESSABLE_ENTITY'));

    return r.table('{{snakeCasePlural}}')
    .get({{camelCase}}.id)
    .update(rethinkdb.ifRevMatches({{camelCase}}), { returnChanges: true })
    .run()
    .then(rethinkdb.checkRevError)
    .then(rethinkdb.firstChange);
  },
  delete: (id) => {
    return r.table('{{snakeCasePlural}}').get(id).delete({ returnChanges: true }).run()
    .then(res => {
      return res;
    })
    .then(rethinkdb.firstChange);
  }
};
