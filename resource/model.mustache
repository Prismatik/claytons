const HttpError = require('standard-http-error');
const uuid = require('uuid');
const r = require('../../lib/db');
const rethinkdb = require('../../lib/rethinkdb');
const schema = require('../../lib/schema');

const validate = schema.getValidator('{{camelCase}}');

module.exports = {
  get: (initialParams, rt) => {
    const { query: initialQuery, indexes, params } = rethinkdb.queryBuilder('{{snakeCasePlural}}', '{{camelCase}}', initialParams);
    let query = initialQuery;
    query = rethinkdb.addTransformations(query, indexes, params);

    let warns = [];
    if (rt) {
      const ret = rethinkdb.changeFeed(query, '{{snakeCasePlural}}');
      warns = ret.warns;
      query = ret.query;
    }

    return rethinkdb.queryWithCount(initialQuery, query, params, warns);
  },
  create: ({{camelCase}}) => {
    const valid = validate({{camelCase}});
    if (!valid) return Promise.reject(new HttpError('UNPROCESSABLE_ENTITY'));
    {{camelCase}}.rev = uuid.v4();
    return r.table('{{snakeCasePlural}}').insert({{camelCase}}, { returnChanges: true }).run()
    .then(rethinkdb.firstChange);
  },
  update: ({{camelCase}}) => {
    if (!{{camelCase}}.rev) {
      return Promise.reject(new HttpError('BAD_REQUEST', 'No rev provided'));
    }

    const valid = validate({{camelCase}});
    if (!valid) return Promise.reject(new HttpError('UNPROCESSABLE_ENTITY'));

    return r.table('{{snakeCasePlural}}')
    .get({{camelCase}}.id)
    .update(rethinkdb.ifRevMatches({{camelCase}}), { returnChanges: true })
    .run()
    .then(rethinkdb.checkRevError)
    .then(rethinkdb.firstChange);
  },
  delete: (id) => {
    return r.table('{{snakeCasePlural}}').get(id).delete({ returnChanges: true }).run()
    .then(rethinkdb.firstChange);
  }
};
