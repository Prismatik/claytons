const _ = require('lodash');
const r = require('./db');
const HttpError = require('standard-http-error');
const bunyan = require('bunyan');
const log = require('./logger');

const model = require('./model');
const schema = require('./schema');
const warnings = require('../constants/warnings');

const limitRegexp = /\.limit\(([^\)]*)\)/m;
const orderByRegexp = /\.orderBy\(([^\)]*)\)/m;
const filterRegexp = /\.filter\(([^\)]*)\)/m;
const skipRegexp = /\.skip\(([^\)]*)\)/m;

exports.firstChange = res => {
  const change = res.changes[0];

  return {
    result: change.new_val || change,
    old_val: change.old_val
  };
};

exports.addTransformations = (table, indexes, params) => {
  return ['orderBy', 'skip', 'limit'].reduce((q, item) => {
    if (params[item]) {
      if (item === 'orderBy') {
        const order = params.order || 'asc';
        const isIndexed = _.includes(indexes, 'orderBy');
        if (isIndexed) q = q[item]({ index: r[order](params[item]) });
        else q = q[item](r[order](params[item]));
      } else {
        q = q[item](params[item]);
      }
    }
    return q;
  }, table);
};

exports.queryBuilder = (tableName, modelName, params, primaryIndex = 'id') => {
  const appSchema = require('../schema').getSchema();
  const modelSchema = appSchema[modelName];

  params = _.assign({ result: true }, model.normaliseParams(params));
  const queryParams = schema.filter(modelName, params);

  const indexes = model.getIndexes(modelSchema, queryParams);
  const indexBy = _.includes(indexes, primaryIndex) ? primaryIndex : indexes[0];

  const query = exports.buildQuery(tableName, indexBy, queryParams);

  return { query, indexes, params };
};

exports.buildQuery = (tableName, indexBy, queryParams) => {
  let query = r.table(tableName);

  // if only id passed, run query using .get(x)
  if (queryParams.id && Object.keys(queryParams).length === 1) return query.get(queryParams.id);

  if (indexBy != null) {
    query = query.getAll(queryParams[indexBy], { index: indexBy });
    delete queryParams[indexBy];
  }

  if (!_.isEmpty(queryParams)) query = query.filter(queryParams);

  return query;
};

// refer changefeed limitations here:-
// https://rethinkdb.com/docs/changefeeds/javascript/
// this prevents "RqlRuntimeError: Cannot call `changes` on an eager stream in"
exports.isChangeFeedable = (query) => {
  query = query.toString();

  const orderBy = orderByRegexp.exec(query);
  const limit = limitRegexp.test(query);
  const skip = skipRegexp.test(query);
  const filter = filterRegexp.exec(query);

  // if filter is used, index must also be used (getAll)
  if (orderBy && !limit) return false;
  if (limit && !orderBy) return false;
  // this issue is not documented but causes the same problem as limit without orderBy
  if (skip && !orderBy) return false;
  if (orderBy && orderBy[1].indexOf('index') === -1) return false;
  if (filter && orderBy && filter.index > orderBy.index) return false;
  return true;
};

exports.checkRevError = res => {
  if (res.first_error === 'rev does not match') {
    throw new HttpError('BAD_REQUEST', res.first_error);
  }
  return res;
};

exports.ifRevMatches = update => {
  return doc => {
    return r.branch(
      doc('rev').eq(update.rev),
      update,
      r.error('rev does not match')
    );
  };
};

exports.changeFeed = (query, tableName) => {
  const warns = [];

  if (!exports.isChangeFeedable(query)) {
    warns.push(warnings.RESTRICTED_FEED);
    log.warn(warnings.RESTRICTED_FEED);
    query = r.table(tableName).getAll(r.args(query.getField('id').coerceTo('array')));
  }

  const changes = { includeInitial: true, includeStates: true };

  return {
    warns,
    query: query.changes(changes)
  };
};

exports.queryWithCount = (query, transformedQuery, params, warns) => {
  const taggedQueries = [
    { tag: 'result', q: transformedQuery },
    { tag: 'count', q: query.count() }
  ].filter(x => params[x.tag]);

  return Promise.all(taggedQueries.map(x => x.q.run()))
  .then(results => {
    return results.reduce((response, result, i) => {
      const tag = taggedQueries[i].tag;
      response[tag] = result;
      if (tag === 'count' && result > 0) response.found = true;
      if (tag === 'result' && result && result.length > 0) response.found = true;
      return response;
    }, { found: false, warns });
  });
};
