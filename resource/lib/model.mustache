exports.normaliseParams = params => {
  return Object.keys(params).reduce((p, k) => {
    const param = params[k];

    p[k] = param;
    if (!isNaN(Number(param))) p[k] = Number(param);
    if (param === 'true') p[k] = true;
    if (param === 'false') p[k] = false;

    return p;
  }, {});
};

exports.getIndexes = (schema, params) => {
  const props = schema.properties;
  const fields = Object.keys(params);

  return fields.filter(f => props[f] && props[f].indexed).sort();
};

const Ajv = require('ajv');
const ajv = new Ajv({ allErrors: true });
const { thinky, schemas } = require('../config');

exports.create = (modelName) => {
  const schema = schemas[modelName];
  const validate = ajv.compile(schema);
  const validator = document => {
    if (!validate(document)) {
      throw new thinky.Errors.ValidationError(
        validate.errors.map(e => e.message).join(', ')
      );
    }
  };

  return thinky.createModel(
    schema.camelCasePlural,
    exports.toThinkySchema(schema.properties),
    { validator, enforce_extra: 'strict' }
  );
};

exports.toThinkySchema = (properties) => {
  const schema = {};
  const typesToTypes = {
    string: String,
    email: thinky.type.string().email(),
    number: Number,
    integer: thinky.type.number().integer(),
    date: Date,
    boolean: Boolean,
    array: [],
    object: {}
  };

  Object.keys(properties).forEach(name => {
    const type = properties[name].type;
    const Type = typesToTypes[type];

    if (!Type) throw new Error(`can't compute property type: ${type} for property: ${name}`);

    if (type === 'array') {
      schema[name] = [typesToTypes[properties[name].items.type]];
    } else if (type === 'object') {
      schema[name] = exports.toThinkySchema(properties[name].properties);
    } else if (type === 'string' && properties[name].enum) {
      schema[name] = thinky.type.string().enum(properties[name].enum);
    } else if (type === 'string' && properties[name].format === 'email') {
      schema[name] = typesToTypes.email;
    } else {
      schema[name] = Type;
    }
  });

  return schema;
};
