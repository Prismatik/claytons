const Ajv = require('ajv');
const { thinky, schemas } = require('../config');

/**
 * Creates a Thiky model based on a schema definition
 *
 * @param {String} model name (in JSON schema)
 * @return {Class} thinky model
 */
exports.create = (modelName) => {
  const schema = schemas[modelName];
  const validator = exports.thinkyValidatorFor(schema);
  const model = thinky.createModel(
    schema.camelCasePlural,
    exports.toThinkySchema(schema.properties),
    { validator, enforce_extra: 'strict' }
  );

  exports.findIndexes(schema).forEach(name => {
    model.ensureIndex(name);
  });

  model.standardQuery = exports.queryBuilder(model, schema);

  return model;
};

/**
 * Finds the names of properties that are marked as indexed in the schema
 *
 * @param {Object} model JSON schema
 * @return {Array} field names
 */
exports.findIndexes = (schema) => {
  return Object.keys(schema.properties)
    .filter(p => schema.properties[p].indexed);
};

/**
 * Builds a Thinky compatible data validator out of the JSON Schema
 *
 * @param {Object} model JSON schema
 * @return {Function} thinky compatible validator
 */
exports.thinkyValidatorFor = (schema) => {
  const ajv = new Ajv({ allErrors: true });
  const validate = ajv.compile(schema);
  return document => {
    if (!validate(document)) {
      throw new thinky.Errors.ValidationError(
        validate.errors.map(e => e.message).join(', ')
      );
    }
  };
};

/**
 * Converts a JSON schema properties into a Thinky model properties config
 *
 * @param {Object} model JSON schema properties
 * @return {Object} thinky compatible properties config
 */
exports.toThinkySchema = (properties) => {
  const schema = {};

  Object.keys(properties).forEach(name => {
    schema[name] = exports.toThinkyType(properties[name]);
  });

  return schema;
};

const typesToTypes = {
  string: String,
  number: Number,
  integer: thinky.type.number().integer(),
  date: Date,
  boolean: Boolean,
  array: [],
  object: {}
};

/**
 * Converts a JSON schema field config into a Thinky based field type
 *
 * @param {Object} JSON property definition
 * @return {Object} thinky type thing
 */
exports.toThinkyType = (property) => {
  const type = property.type;
  const Type = typesToTypes[type];

  if (!Type) throw new Error(`can't compute property type: ${type} for property: ${property}`);

  switch (type) {
    case 'array': {
      if (property.items.type === 'object') {
        return [exports.toThinkySchema(property.items.properties)];
      }
      if (property.items.type === 'array') {
        return property.items.map(exports.toThinkySchema);
      }
      return [typesToTypes[property.items.type]];
    }
    case 'object': return exports.toThinkySchema(property.properties);
    case 'string': return property.enum ? thinky.type.string().enum(property.enum) : Type;
    default:
      return Type;
  }
};

/**
 * A standard query builder (used in controllers)
 *
 * @param {Class} thinky model
 * @param {Object} model json schema
 * @return {Function} a query builder
 */
exports.queryBuilder = (model, schema) => (params = {}) => {
  let query = model;
  const filter = {};

  Object.keys(params).forEach(key => {
    if (schema.properties[key]) {
      filter[key] = params[key];
    }
  });

  if (Object.keys(filter).length > 0) {
    query = query.filter(filter);
  }

  if (params.orderBy && schema.properties[params.orderBy]) {
    const direction = params.order || 'asc';
    query = query.orderBy(params.orderBy, direction);
  }

  if (params.skip && !isNaN(parseInt(params.skip, 10))) {
    query = query.skip(parseInt(params.skip, 10));
  }

  if (params.limit && !isNaN(parseInt(params.limit, 10))) {
    query = query.limit(parseInt(params.limit, 10));
  }

  return query;
};
