{{=<% %>=}}
const fetch = require('node-fetch');
const querystring = require('querystring');
const _ = require('lodash');
const uuid = require('uuid');
const fixture = require('../../fixtures/<%snakeCase%>');
const IO = require('socket.io-client');
<%#isUser%>
const password = require('simple-password');
const errors = require('../../constants/errors');
const HASH_ROUNDS = parseInt(process.env.HASH_ROUNDS, 10);
<%/isUser%>
const warnings = require('../../constants/warnings');
<%#relationships%>
const <%camelCase%>Fixture = require('../../fixtures/<%snakeCase%>');
<%/relationships%>

const url = `http://localhost:${process.env.PORT}`;

<%#isUser%>
const statusEquals = code => res => {
  res.status.must.equal(code);
  return res;
};

<%/isUser%>
const asc = (a, b) => {
  if (a.id > b.id) return 1;
  if (a.id < b.id) return -1;
  return 0;
};

const desc = (a, b) => {
  if (a.id < b.id) return 1;
  if (a.id > b.id) return -1;
  return 0;
};

const unwrapOldVal = (res) => {
  return res.json()
  .then(json => json.old_val);
};

const unwrapJSON = (res) => {
  return res.json()
  .then(json => json.result);
};

const getJSON = (path) => {
  return fetch(url + path)
  .then(unwrapJSON);
};

const sender = method => path => data => {
  return fetch(url + path, {
    method,
    headers: {
      Accept: 'application/json',
      'Content-Type': 'application/json'
    },
    body: JSON.stringify(data)
  });
};

const poster = sender('post');
const putter = sender('put');

const deleter = path => () => {
  return fetch(url + path, {
    method: 'delete',
    headers: {
      Accept: 'application/json'
    }
  });
};

const <%camelCase%>Poster = poster('/<%kebabCasePlural%>');

const <%camelCase%>Creator = times => {
  return Promise.all(_.times(times, () => {
    const data = fixture.valid();
    <%^isUser%>
    return <%camelCase%>Poster(data)
    .then(unwrapJSON);
    <%/isUser%>
    <%#isUser%>
    return password.create(data.password, HASH_ROUNDS)
    .then(pass => {
      data.password = pass;
      return <%camelCase%>Poster(data)
      .then(unwrapJSON);
    });
    <%/isUser%>
  }));
};

const pop = data => data[0];

const single<%pascalCase%>Creator = () => <%camelCase%>Creator(1).then(pop);

<%#relationships%>
// <%camelCase%> relationship helpers
const <%camelCase%>Poster = poster('/<%kebabCasePlural%>');

const <%camelCase%>Creator = times => {
  return Promise.all(_.times(times, () => {
    const data = <%camelCase%>Fixture.valid();
    return <%camelCase%>Poster(data)
    .then(unwrapJSON);
  }));
};

const single<%pascalCase%>Creator = () => <%camelCase%>Creator(1).then(pop);
<%/relationships%>

describe('<%camelCase%> model', () => {
  describe('GET /<%kebabCasePlural%>', () => {
    it('returns 200 ok', () => {
      return single<%pascalCase%>Creator()
        .then(() => fetch(`${url}/<%kebabCasePlural%>`))
        .must.resolve.to.have.property('status', 200);
    });

    it('return an object with a .result property', () => {
      return single<%pascalCase%>Creator()
        .then(() => fetch(`${url}/<%kebabCasePlural%>`))
        .then(res => res.json())
        .must.resolve.to.be.object();
    });

    it('accepts search params in the querystring', () => {
      return <%camelCase%>Creator(2)
        .then(entries => {
          const record = entries[0];
          const property = Object.keys(record).filter(k => k !== 'id')[0];
          if (!property) return Promise.resolve(); // if no properties other than id skip test
          const queryStr = querystring.stringify({ [property]: record[property] });

          return getJSON(`/<%kebabCasePlural%>?${queryStr}`)
            .then(json => json.map(entry => entry[property]))
            .must.resolve.to.eql([record[property]]);
        });
    });

    it('does not match non-property search params in the querystring', () => {
      return <%camelCase%>Creator(2)
        .then(<%camelCasePlural%> => {
          const id = <%camelCasePlural%>[0].id;
          return getJSON(`/<%kebabCasePlural%>?foo=${id}`);
        })
        .then(entries => entries.length)
        .must.resolve.to.be.gt(1);
    });

    it('paginates data when asked', () => {
      return <%camelCase%>Creator(5)
        .then(() => getJSON('/<%kebabCasePlural%>?limit=2'))
        .must.resolve.to.have.length(2);
    });

    it('skips records when asked', () => {
      return <%camelCase%>Creator(5)
        .then(() => getJSON('/<%kebabCasePlural%>?limit=2'))
        .then(first => {
          first.must.have.length(2);
          return getJSON('/<%kebabCasePlural%>?limit=2&skip=2')
            .then(second => {
              second.must.have.length(2);
              second.must.not.eql(first);
            });
        });
    });

    it('orders data when asked', function callback() {
      this.timeout(10000); // Required for user tests because bcrypt takes time
      return <%camelCase%>Creator(15)
        .then(() => getJSON('/<%kebabCasePlural%>?orderBy=id'))
        .then(results => {
          const reordered = _.clone(results).sort(asc);

          _.map(reordered, 'id').must.eql(_.map(results, 'id'));
        });
    });

    it('orders data in reverse when asked', function callback() {
      this.timeout(10000); // Required for user tests because bcrypt takes time
      return <%camelCase%>Creator(15)
        .then(() => getJSON('/<%kebabCasePlural%>?orderBy=id&order=desc'))
        .then(results => {
          const reordered = _.clone(results).sort(desc);

          _.map(reordered, 'id').must.eql(_.map(results, 'id'));
        });
    });

    it('returns n matching docs with a count of all matching docs', () => {
      return <%camelCase%>Creator(10)
        .then(() => fetch(`${url}/<%kebabCasePlural%>?count=true&limit=5`))
        .then(res => res.json())
        .then(json => {
          json.result.must.have.length(5);
          json.count.must.be.gt(5);
        });
    });

    it('returns n matching docs without a count of all matching docs ', () => {
      return <%camelCase%>Creator(10)
        .then(() => fetch(`${url}/<%kebabCasePlural%>?limit=5`))
        .then(res => res.json())
        .then(json => {
          json.result.must.have.length(5);
          json.must.not.have.property('count');
        });
    });

    it('returns only a count with no matching docs', () => {
      return <%camelCase%>Creator(10)
        .then(() => fetch(`${url}/<%kebabCasePlural%>?count=true&result=false`))
        .then(res => res.json())
        .then(json => {
          json.must.not.have.property('result');
          json.count.must.be.gt(5);
        });
    });
  });

  describe('GET /<%kebabCasePlural%>/:id', () => {
    it('returns 200 with the record data', () => {
      return single<%pascalCase%>Creator()
        .then(record => fetch(`${url}/<%kebabCasePlural%>/${record.id}`))
        .must.resolve.to.have.property('status', 200);
    });
  });

  describe('POST /<%kebabCasePlural%>', () => {
    it('returns 201 for valid data', () => {
      return <%camelCase%>Poster(fixture.valid())
        .must.resolve.to.have.property('status', 201);
    });

    it('returns 422 for invalid data', () => {
      const invalid = fixture.valid();
      invalid.rev = 'lol';
      return <%camelCase%>Poster(invalid)
        .must.resolve.to.have.property('status', 422);
    });

    it('actually persists the data', () => {
      return single<%pascalCase%>Creator()
        .then(record => {
          return getJSON(`/<%kebabCasePlural%>/${record.id}`)
            .must.resolve.to.have.property('id', record.id);
        });
    });
    <%#isUser%>
    it('returns 422 for creation with no password', () => {
      const invalid = fixture.valid();
      delete invalid.password;
      return <%camelCase%>Poster(invalid)
        .must.resolve.to.have.property('status', 422);
    });

    it('returns a meaningful error message for a create with no password', () => {
      const invalid = fixture.valid();
      delete invalid.password;
      return <%camelCase%>Poster(invalid)
        .then(res => res.json())
        .must.resolve.to.have.property('message', errors.NO_PASSWORD);
    });
    <%/isUser%>
    <%#relationships%>

    it('saves related entity (can GET using :id)', () => {
      return single<%pascalCase%>Creator()
        .then(body => fetch(`${url}/<%kebabCasePlural%>/${body.id}`))
        .must.resolve.to.have.property('status', 200);
    });
    <%/relationships%>
  });

  describe('PUT /<%kebabCasePlural%>/:id', () => {
    it('updates <%camelCase%> and actually persists it', () => {
      const update = { name: 'Something else' };
      return single<%pascalCase%>Creator()
        .then(body => putter(`/<%kebabCasePlural%>/${body.id}`)(_.merge(body, update)))
        .then(unwrapJSON)
        .then(body => getJSON(`/<%kebabCasePlural%>/${body.id}`))
        .must.resolve.to.have.property('name', update.name);
    });

    it('rejects a <%camelCase%> without any rev', () => {
      const update = { name: 'Something else' };
      return single<%pascalCase%>Creator()
        .then(body => putter(`/<%kebabCasePlural%>/${body.id}`)(update))
        .then(res => res.status.must.equal(400));
    });

    it('rejects a <%camelCase%> with a faulty rev', () => {
      const update = { name: 'Something else', rev: uuid.v4() };
      return single<%pascalCase%>Creator()
        .then(body => putter(`/<%kebabCasePlural%>/${body.id}`)(_.merge(body, update)))
        .then(res => res.status.must.equal(400));
    });
    <%#isUser%>

    it('PUTing an updated password should update the password hash', () => {
      const update = { password: 'ABCD1234' };
      return single<%pascalCase%>Creator()
      .then(body => putter(`/<%kebabCasePlural%>/${body.id}`)(_.merge(body, update)))
      .then(unwrapJSON)
      .then(body => getJSON(`/<%kebabCasePlural%>/${body.id}`))
      .then(json => password.verify(update.password, json.password))
      .must.resolve.to.equal(true);
    });
    <%/isUser%>
  });

  describe('DELETE /<%kebabCasePlural%>/:id', () => {
    it('returns 200 ok response', () => {
      return single<%pascalCase%>Creator()
        .then(body => deleter(`/<%kebabCasePlural%>/${body.id}`)())
        .must.resolve.to.have.property('status', 200);
    });

    it('actually deletes the record', () => {
      return single<%pascalCase%>Creator()
        .then(body => deleter(`/<%kebabCasePlural%>/${body.id}`)())
        .then(unwrapOldVal)
        .then(body => fetch(`${url}/<%kebabCasePlural%>/${body.id}`))
        .must.resolve.to.have.property('status', 404);
    });
  });

  <%#isUser%>
  describe('POST /<%kebabCasePlural%>/signin', () => {
    it('returns 401 response with invalid email', () => {
      const signin = poster('/<%kebabCasePlural%>/signin');
      return signin({ email: 'notexist@example.com', password: 'ABCD1234' })
        .then(statusEquals(401))
        .then(res => res.json())
        .must.resolve.to.have.property('message', 'Unauthorized');
    });

    it('returns 401 response with incorrect password', () => {
      const data = fixture.valid();
      return <%camelCase%>Poster(data)
      .then(unwrapJSON)
      .then(() => {
        const signin = poster('/<%kebabCasePlural%>/signin');
        return signin({ email: data.email, password: 'ABCD1234' })
          .then(statusEquals(401))
          .then(res => res.json())
          .must.resolve.to.have.property('message', 'Unauthorized');
      });
    });

    it('POST /<%kebabCasePlural%>/signin with correct credentials should return a valid jwt',
    () => {
      const data = fixture.valid();
      return <%camelCase%>Poster(data)
      .then(unwrapJSON)
      .then((user) => {
        const signin = poster('/<%kebabCasePlural%>/signin');
        return signin({ email: data.email, password: data.password })
          .then(statusEquals(200))
          .then(res => res.json())
          .then(json => {
            json.found.must.be.true();
            json.result.token.must.not.be.null();
            json.result.user.must.eql(_.omit(user, 'password'));
          });
      });
    });
  });
  <%/isUser%>

  describe('Socket connection', () => {
    it('opens a web-socket connection and returns a single record', () => {
      return single<%pascalCase%>Creator()
        .then(body => {
          return new Promise(resolve => {
            const opts = { query: `id=${body.id}`, forceNew: true };
            const io = IO(`${url}/<%kebabCasePlural%>`, opts);
            io.on('record', data => {
              resolve(data.new_val);
              io.disconnect();
            });
          })
          .must.resolve.to.eql(body);
        });
    });

    it('opens a websocket connection to <%camelCasePlural%> should return all of them', () => {
      return <%camelCase%>Creator(2)
        .then(() => {
          return new Promise(resolve => {
            const opts = { forceNew: true };
            const io = IO(`${url}/<%kebabCasePlural%>`, opts);
            let count = 0;
            io.on('record', () => {
              count++;
              if (count > 1) {
                resolve(count);
                io.disconnect();
              }
            });
          })
          .must.resolve.to.eql(2);
        });
    });

    it('opens a websocket connection to <%camelCasePlural%> and returns changed documents',
    () => {
      return single<%pascalCase%>Creator()
        .then(data => {
          <%^isUser%>
          const update = Object.assign({}, data, { name: 'ohai' });
          <%/isUser%>
          <%#isUser%>
          const update = Object.assign({}, _.omit(data, 'password'), { name: 'ohai' });
          <%/isUser%>
          return new Promise(resolve => {
            const opts = { forceNew: true };
            const io = IO(`${url}/<%kebabCasePlural%>`, opts);
            io.on('state', state => {
              if (state.state === 'ready') {
                io.on('record', record => {
                  <%^isUser%>
                  const result = record.new_val;
                  <%/isUser%>
                  <%#isUser%>
                  const result = _.omit(record.new_val, 'password');
                  <%/isUser%>
                  result.must.eql(update);
                  io.disconnect();
                  resolve();
                });
                putter(`/<%kebabCasePlural%>/${data.id}`)(update);
              }
            });
          });
        });
    });

    it('accepts the same filter params as GET requests', () => {
      return <%camelCase%>Creator(2)
        .then(<%camelCasePlural%> => {
          const target = <%camelCasePlural%>[0];
          const targetKey = Object.keys(target).filter(k => k !== 'id')[0];
          return new Promise(resolve => {
            const query = [targetKey].reduce((r, k) => {
              r[k] = target[k];
              return r;
            }, {});
            const opts = { query, forceNew: true };
            const io = IO(`${url}/<%kebabCasePlural%>`, opts);
            io.on('record', data => {
              data.new_val.must.eql(target);
            });
            io.on('state', data => {
              if (data.state !== 'ready') return;
              io.disconnect();
              resolve();
            });
          });
        });
    });

    it('accepts the same limit param as GET requests', () => {
      return <%camelCase%>Creator(2)
        .then(() => {
          return new Promise(resolve => {
            const opts = { query: { limit: 1 }, forceNew: true };
            const io = IO(`${url}/<%kebabCasePlural%>`, opts);
            let count = 0;
            io.on('record', () => count++);
            io.on('state', data => {
              if (data.state !== 'ready') return;
              count.must.eql(1);
              io.disconnect();
              resolve();
            });
          });
        });
    });

    it('emits a warning on an unchangefeedable query', () => {
      return <%camelCase%>Creator(2)
        .then(() => {
          return new Promise(resolve => {
            const opts = { query: { limit: 1 }, forceNew: true };
            const io = IO(`${url}/<%kebabCasePlural%>`, opts);
            let warned = false;
            io.on('warning', (warn) => {
              if (warn === warnings.RESTRICTED_FEED) warned = true;
            });
            io.on('state', data => {
              if (data.state !== 'ready') return;
              io.disconnect();
              warned.must.be.true();
              resolve();
            });
          });
        });
    });

    it('skips records if asked', () => {
      return <%camelCase%>Creator(5)
        .then(() => {
          return new Promise(resolve => {
            const opts = { query: { limit: 1 }, forceNew: true };
            const io = IO(`${url}/<%kebabCasePlural%>`, opts);
            let first;
            io.on('record', record => {
              first = record;
              io.disconnect();
              const opts2 = { query: { skip: 1 }, forceNew: true };
              const io2 = IO(`${url}/<%kebabCasePlural%>`, opts2);
              io2.on('record', record2 => {
                record2.must.not.eql(first);
                io2.disconnect();
                return resolve();
              });
            });
          });
        });
    });
  });
});
