{{#isUser}}
const HttpError = require('standard-http-error');
const password = require('simple-password');
const _ = require('lodash');
const jwt = require('../../lib/jwt');
const HASH_ROUNDS = parseInt(process.env.HASH_ROUNDS, 10);
const errors = require('../../config/errors');
{{/isUser}}
const model = require('../models/{{snakeCase}}.js');

module.exports = {
  get: query => {
    return model.get(query);
  },
  {{^isUser}}
  create: body => {
    return model.create(body);
  },
  update: body => {
    return model.update(body);
  },
  {{/isUser}}
  {{#isUser}}
  create: body => {
    if (!body.password) return Promise.reject(new HttpError(422, errors.NO_PASSWORD));
    return password.create(body.password, HASH_ROUNDS)
    .then(hash => {
      const data = _.merge(body, { password: hash });
      return model.create(data);
    });
  },
  update: body => {
    const getHash = body.password ?
      password.create(body.password, HASH_ROUNDS)
      : Promise.resolve();

    return getHash.then(pass => {
      if (pass) body.password = pass;
      return body;
    })
    .then(model.update);
  },
  signin: (email, pass) => {
    return model.get({ email })
    .then((res) => {
      const users = res.result;
      if (users.length === 0) throw new HttpError('UNAUTHORIZED');
      const user = users[0];
      return password.verify(pass, user.password)
      .then(verified => {
        if (verified) return jwt.sign({ id: user.id, role: user.role });
        throw new HttpError('UNAUTHORIZED');
      })
      .then(token => {
        return {
          found: true,
          result: { token, user: _.omit(user, 'password') }
        };
      });
    });
  },
  signout: body => {
    return model.signout(body);
  },
  {{/isUser}}
  delete: id => {
    return model.delete(id);
  },
  watch: query => {
    return model.get(query, true);
  }
};
