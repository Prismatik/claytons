const Ajv = require('ajv');
const uuid = require('uuid');
const { thinky, schema } = require('../../config');

/**
 * Creates a Thiky model based on a schema definition
 *
 * @param {String} model name (in JSON schema)
 * @return {Class} thinky model
 */
exports.create = (modelName, opts = {}) => {
  const modelSchema = schema[modelName];
  const validator = exports.thinkyValidatorFor(modelSchema);
  const model = thinky.createModel(
    modelSchema.pluralName,
    { /* we are relying on the JSON schema validator to ensure data consitency */ },
    { validator, enforce_extra: 'none', enforce_type: 'none' }
  );

  if (modelSchema.properties.rev) {
    exports.setRevLifecycle(model);
  }

  model.standardQuery = exports.queryBuilder(model, modelSchema);
  model.standardFeed = exports.feedBuilder(model);

  if (opts.audit) { exports.setupAuditLog(model); }

  return model;
};

/**
 * Builds a Thinky compatible data validator out of the JSON Schema
 *
 * @param {Object} model JSON schema
 * @return {Function} thinky compatible validator
 */
exports.thinkyValidatorFor = (schema) => {
  const ajv = new Ajv({ allErrors: true });
  const validate = ajv.compile(schema);
  const humanReadableErrors = errors => errors.map(error => {
    const { dataPath, message, keyword, params: { missingProperty } } = error;
    const path = keyword === 'required' ? dataPath + `.${missingProperty}` : dataPath;
    const text = keyword === 'required' ? 'is required' : message.replace('should', 'must');

    return `\`${path.replace(/^\./, '')}\` ${text}`;
  });

  return document => {
    if (!validate(document)) {
      throw new thinky.Errors.ValidationError(
        humanReadableErrors(validate.errors).join(', ')
      );
    }
  };
};

/**
 * A standard query builder (used in controllers)
 *
 * @param {Class} thinky model
 * @param {Object} model json schema
 * @return {Function} a query builder
 */
exports.queryBuilder = (model, schema) => (params = {}) => {
  let query = model;
  const filter = {};

  Object.keys(params).forEach(key => {
    if (schema.properties[key]) {
      filter[key] = params[key];
    }
  });

  if (Object.keys(filter).length > 0) {
    query = query.filter(filter);
  }

  if (params.orderBy && schema.properties[params.orderBy]) {
    const direction = params.order || 'asc';
    query = query.orderBy(params.orderBy, direction);
  }

  if (params.skip && !isNaN(parseInt(params.skip, 10))) {
    query = query.skip(parseInt(params.skip, 10));
  }

  if (params.limit && !isNaN(parseInt(params.limit, 10))) {
    query = query.limit(parseInt(params.limit, 10));
  }

  return query;
};

/**
 * Creates a standard change feed for apps
 *
 * @param {Classs} model
 * @return {Function} feed builer
 */
exports.feedBuilder = (Model) => (params = {}) => {
  const changeParams = { includeInitial: true, includeStates: true };

  return Model.standardQuery(params).changes(changeParams).then(feed => Object.assign(feed, {
    listen(callback) {
      let allLoaded = false;

      feed.feed.each((err, doc) => {
        if (err) {
          callback(err);
        } else if (doc.state) {
          if (doc.state === 'ready') {
            callback(null, 'all:loaded', allLoaded = true);
          }
        } else if (doc.new_val && !doc.old_val) {
          callback(null, allLoaded ? 'created' : 'existed', new Model(doc.new_val));
        } else if (!doc.new_val && doc.old_val) {
          callback(null, 'deleted', new Model(doc.old_val));
        } else if (doc.new_val && doc.old_val) {
          callback(null, 'updated', new Model(doc.new_val));
        }
      });
    }
  }));
};

/**
 * Sets up an audit log model that saves previous states of records
 *
 * @param {Class} model
 * @return void
 */
exports.setupAuditLog = (model) => {
  const AuditModel = thinky.createModel(
    `${model.getTableName()}AuditLog`,
    {
      createdAt: Date,
      doc: Object
    }
  );

  model.post('save', function (next) {
    new AuditModel({
      createdAt: new Date(),
      doc: Object.assign({}, this)
    }).save(next);
  });

  model.AuditModel = AuditModel;

/**
 * Sets up the `rev` properties lifecycles
 *
 * @param {class} thinky model
 * @return void
 */
exports.setRevLifecycle = Model => {
  Model.pre('save', function (next) {
    if (!this.isSaved() && !this.rev) {
      this.rev = uuid.v4();
    }

    next();
  });
};
