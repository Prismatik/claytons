const uuid = require('uuid');
const { app } = require('../helper');
const {{pascalCase}} = require('../../src/models/{{snakeCase}}');
const {{camelCasePlural}} = require('../../src/controllers/{{snakeCasePlural}}');
const {{camelCase}}Fixture = require('../fixtures/{{snakeCase}}');
const IO = require('socket.io-client');

describe('/{{kebabCasePlural}} route', () => {
  let {{camelCase}};
  let {{camelCase}}1;
  let {{camelCase}}2;

  const sorted = (records, param = 'id') => records
    .sort((a, b) => (a[param] > b[param] ? 1 : -1))
    .map(i => Object.assign({}, i)){{#isUser}}
    .map(i => { delete(i.password); return i; })
    {{/isUser}};

  beforeEach(function * () {
    yield {{pascalCase}}.delete().execute();

    [{{camelCase}}1, {{camelCase}}2] = yield [
      {{camelCasePlural}}.create({{camelCase}}Fixture.valid()),
      {{camelCasePlural}}.create({{camelCase}}Fixture.valid())
    ];

    {{camelCase}} = {{camelCase}}1;
  });

  describe('GET /', () => {
    it('returns all records by default', function * () {
      const response = yield app.get('/{{kebabCasePlural}}');
      response.status.must.eql(200);
      response.body.must.be.an(Array);
      sorted(response.body).must.eql(sorted([{{camelCase}}1, {{camelCase}}2]));
    });

    it('allows to specify property filters', function * () {
      const response = yield app.get('/{{kebabCasePlural}}', { id: {{camelCase}}1.id });
      response.status.must.eql(200);
      sorted(response.body).must.eql(sorted([{{camelCase}}1]));
    });

    it('allows to sort data by fields', function * () {
      const response = yield app.get('/{{kebabCasePlural}}', { orderBy: 'rev' });
      response.status.must.eql(200);
      sorted(response.body, 'rev').must.eql(sorted([{{camelCase}}1, {{camelCase}}2], 'rev'));
    });

    it('allows `limit` data', function * () {
      const response = yield app.get('/{{kebabCasePlural}}', { limit: 1, orderBy: 'rev' });
      response.status.must.eql(200);
      response.body.must.eql(sorted([{{camelCase}}1, {{camelCase}}2], 'rev').slice(0, 1));
    });
  });

  describe('GET /:id', () => {
    it('returns the record if exists', function * () {
      const response = yield app.get('/{{kebabCasePlural}}/' + {{camelCase}}.id);
      response.status.must.eql(200);
      response.body.must.be.object();
      {{#isUser}}
      delete({{camelCase}}.password);
      {{/isUser}}
      response.body.must.eql(Object.assign({}, {{camelCase}}));
    });

    it('throws 404 when the record does not exist', function * () {
      const response = yield app.get(`/{{kebabCasePlural}}/hack`);
      response.status.must.eql(404);
      response.body.must.eql({ error: 'not found' });
    });
  });

  describe('POST /', () => {
    it('creates new record when data is good', function * () {
      const data = {{camelCase}}Fixture.valid(); delete(data.id);
      const response = yield app.post('/{{kebabCasePlural}}', data);
      response.status.must.eql(201);
      response.body.must.be.object();
      {{#isUser}}
      response.body.must.not.have.property('password');
      {{/isUser}}
      const {{camelCase}} = response.body;

      delete({{camelCase}}.id); delete({{camelCase}}.rev);
      delete(data.rev);{{#isUser}} delete(data.password);{{/isUser}}

      {{camelCase}}.must.eql(data);
    });

    it('throws 422 if the data is bad', function * () {
      const response = yield app.post('/{{kebabCasePlural}}', {});
      response.status.must.eql(422);
      response.body.must.be.object();
      response.body.must.have.property('error');
      response.body.error.must.contain('is required');
    });
    {{#isUser}}
    it('throws 422 if a password is mising', function * () {
      const data = {{camelCase}}Fixture.valid(); {{#isUser}}delete(data.password);{{/isUser}}
      const response = yield app.post('/{{kebabCasePlural}}', data);
      response.status.must.eql(422);
      response.body.must.eql({
        error: '`password` is required'
      });
    });
    {{/isUser}}
  });

  describe('PUT /:id', () => {
    let validData;

    beforeEach(() => {
      validData = {{camelCase}}Fixture.valid(); delete(validData.id);
    });

    it('replaces an entire document and returns the updated record back', function * () {
      const data = Object.assign({}, validData, { rev: uuid.v4() });
      const response = yield app.put('/{{kebabCasePlural}}/' + {{camelCase}}.id, data);
      response.status.must.eql(200);

      const expected = Object.assign({ id: {{camelCase}}.id }, data);{{#isUser}}
      delete(expected.password);{{/isUser}}

      response.body.must.eql(expected);
    });

    it('throws 404 if the record does not exist', function * () {
      const response = yield app.put('/{{kebabCasePlural}}/hack', {});
      response.status.must.eql(404);
      response.body.must.eql({ error: 'not found' });
    });

    it('throws 422 if some data is missing', function * () {
      const response = yield app.put('/{{kebabCasePlural}}/' + {{camelCase}}.id, {});
      response.status.must.eql(422);
      response.body.error.must.contain('is required');
    });

    it('throws 422 if the data is malformed', function * () {
      const data = Object.assign({}, validData, { rev: 'hack hack hack' });
      const response = yield app.put('/{{kebabCasePlural}}/' + {{camelCase}}.id, data);
      response.status.must.eql(422);
      response.body.must.eql({
        error: '`rev` must match pattern "^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$"'
      });
    });
  });

  describe('PATCH /:id', () => {
    it('updates the data and returns the updated record back', function * () {
      const data = { rev: uuid.v4() };
      const response = yield app.patch('/{{kebabCasePlural}}/' + {{camelCase}}.id, data);
      response.status.must.eql(200);

      const expected = Object.assign({}, {{camelCase}}, data);{{#isUser}}
      delete(expected.password);{{/isUser}}

      response.body.must.eql(expected);
    });

    it('throws 404 if the record does not exist', function * () {
      const response = yield app.patch('/{{kebabCasePlural}}/hack', {});
      response.status.must.eql(404);
      response.body.must.eql({ error: 'not found' });
    });

    it('does not explode if not all data was send through', function * () {
      const response = yield app.patch('/{{kebabCasePlural}}/' + {{camelCase}}.id, {});
      response.status.must.eql(200);
    });

    it('throws 422 if the data is malformed', function * () {
      const data = { rev: 'hack hack hack' };
      const response = yield app.patch('/{{kebabCasePlural}}/' + {{camelCase}}.id, data);
      response.status.must.eql(422);
      response.body.must.eql({
        error: '`rev` must match pattern "^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$"'
      });
    });
  });

  describe('DELETE /:id', () => {
    it('deletes a record if it exists', function * () {
      const response = yield app.delete('/{{kebabCasePlural}}/' + {{camelCase}}.id);
      response.status.must.eql(200);
      const expected = Object.assign({}, {{camelCase}});{{#isUser}}
      delete(expected.password);{{/isUser}}
      response.body.must.eql(expected);
    });

    it('throws 404 if the record does not exist', function * () {
      const response = yield app.delete('/{{kebabCasePlural}}/hack', {});
      response.status.must.eql(404);
      response.body.must.eql({ error: 'not found' });
    });
  });

  describe('socket connection', () => {
    let io;
    const wait = timeout => new Promise(resolve => setTimeout(resolve, timeout));
    const listenFor = event => new Promise((resolve, reject) => {
      io.on(event, data => resolve(data));
      io.on('error', error => reject(error));
    });

    beforeEach(function * () {
      yield wait(50); // waiting for the other beforeEach events to pass
      io = IO(app.urlFor('/{{kebabCasePlural}}'), { forceNew: true });
    });

    afterEach(() => io.disconnect());

    it('allows to open up connection and get metadata back', function * () {
      const metadata = yield listenFor('metadata');
      metadata.must.eql({ count: 2 });
    });

    it('sends through all existing records and the `all:loaded` event', function * () {
      const records = [];
      const allDone = listenFor('all:loaded');
      io.on('existed', record => records.push(record));
      const result = yield allDone;
      result.must.eql({});
      sorted(records).must.eql(sorted([{{camelCase}}1, {{camelCase}}2]));
    });

    it('sends records through when they are created', function * () {
      const feed = listenFor('created'); yield wait(50);
      const newRecord = yield {{camelCasePlural}}.create({{camelCase}}Fixture.valid());
      const feedRecord = yield feed;
      {{#isUser}}
      delete(newRecord.password);
      {{/isUser}}
      feedRecord.must.eql(Object.assign({}, newRecord));
    });

    it('sends notifications about changed objects', function * () {
      const feed = listenFor('updated'); yield wait(50);
      const newData = {{camelCase}}Fixture.valid(); delete(newData.id);
      const updatedRecord = yield {{camelCasePlural}}.update({{camelCase}}.id, newData);
      const feedRecord = yield feed;
      {{#isUser}}
      delete(updatedRecord.password);
      {{/isUser}}
      feedRecord.must.eql(Object.assign({}, updatedRecord));
    });

    it('sends notifications through when {{camelCasePlural}} are deleted', function * () {
      const feed = listenFor('deleted'); yield wait(50);
      const deletedRecord = yield {{camelCasePlural}}.delete({{camelCase}}.id);
      const feedRecord = yield feed;
      {{#isUser}}
      delete(deletedRecord.password);
      {{/isUser}}
      feedRecord.must.eql(Object.assign({}, deletedRecord));
    });
  });
});
