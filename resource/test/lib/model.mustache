const model = require('../../lib/model');
const { thinky } = require('../../config');

const INDEXED = { indexed: true };
const UUID = 'dc83f979-3485-49fc-b180-ba485d01a88f';

describe('lib/model', () => {
  describe('.getIndexes', () => {
    it('Given params match indexed properties, must return all matches', () => {
      const schema = { properties: { favMilk: INDEXED, pilot: INDEXED } };
      const params = {
        favMilk: 'blue',
        id: UUID,
        name: 'Luke Skywalker',
        pilot: true
      };
      const result = model.getIndexes(schema, params);
      result.must.eql(['favMilk', 'pilot']);
    });

    it('Given indexed properties that are not in params must not return these', () => {
      const schema = {
        properties: { pilot: INDEXED, sonOfVader: INDEXED, saberColour: INDEXED }
      };
      const params = {
        favMilk: 'blue',
        id: UUID,
        name: 'Luke Skywalker',
        pilot: true
      };
      const result = model.getIndexes(schema, params);
      result.must.eql(['pilot']);
    });

    it('Given no params match indexed properites, must return an empty array', () => {
      const schema = { properties: { favMilk: INDEXED, pilot: INDEXED } };
      const params = {
        sonOfVader: true,
        saberColour: 'green/blue'
      };
      const result = model.getIndexes(schema, params);
      result.must.eql([]);
    });
  });

  describe('.toThinkySchema(jsonSchemaProperties)', () => {
    const JSON_SCHEMA_PROPS = {
      id: {
        type: 'string',
        pattern: '^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$'
      },
      rev: {
        type: 'string',
        pattern: '^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$'
      },
      name: {
        type: 'string'
      },
      email: {
        type: 'string',
        format: 'email'
      },
      password: {
        type: 'string'
      },
      score: {
        type: 'integer'
      },
      things: {
        type: 'array',
        items: {
          type: 'string',
          pattern: '^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$'
        }
      },
      secrets: {
        type: 'object',
        properties: {
          short: { type: 'string' },
          numeric: { type: 'number' }
        }
      },
      gender: {
        type: 'string',
        enum: ['Female', 'Male']
      },
      drunk: {
        type: 'boolean'
      },
      createdAt: {
        type: 'date'
      }
    };

    it('converts a JSON schema into a thinky schema', () => {
      model.toThinkySchema(JSON_SCHEMA_PROPS).must.eql({
        id: String,
        rev: String,
        name: String,
        email: thinky.type.string().email(),
        password: String,
        score: thinky.type.number().integer(),
        things: [String],
        secrets: {
          short: String,
          numeric: Number
        },
        gender: thinky.type.string().enum(['Female', 'Male']),
        drunk: Boolean,
        createdAt: Date
      });
    });
  });

  describe.only('.create(modelName)', () => {
    const TEST_JSON_SCHEMA = {
      type: 'object',
      name: 'thing',
      camelCasePlural: 'things',
      properties: {
        id: {
          type: 'string',
          pattern: '^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$'
        },
        email: {
          type: 'string',
          format: 'email'
        },
        password: {
          type: 'string'
        }
      },
      required: [
        'email',
        'password'
      ]
    };
    let Model;

    before(() => {
      const { schemas } = require('../../config');
      schemas.thing = TEST_JSON_SCHEMA;
      Model = model.create('thing');
    });

    it('should build a thinky class', () => {
      Model.must.equal(thinky.models.things);
    });

    it('should pick up validations correctly', () => {
      return new Model({}).save().must.reject.with.error(
        thinky.Errors.ValidationError,
        "should have required property 'email', should have required property 'password'"
      );
    });

    it('should handle malformed data as well', () => {
      const params = { email: 'blah!', password: 'blah!' };
      return new Model(params).save().must.reject.with.error(
        thinky.Errors.ValidationError,
        'should match format "email"'
      );
    });
  });
});
