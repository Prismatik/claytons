const rethinkdb = require('../../lib/rethinkdb');
const r = require('../../lib/db');
const UUID = '8f0834ed-ea58-4be9-8cea-ace9893f9b15';

describe('lib/rethinkdb', () => {
  describe('.buildQuery', () => {
    it('must return an unchanged query given no params', () => {
      const query = r.table('test');
      const result = rethinkdb.buildQuery(query, null, {});

      result.toString().must.equal(query.toString());
    });

    it('must return a filered query given filters', () => {
      const query = r.table('test');
      const filters = { name: 'Darth Vader' };
      const result = rethinkdb.buildQuery(query, null, filters);
      const expected = query.filter(filters);

      result.toString().must.equal(expected.toString());
    });

    it('must use an index when filters use an indexed property', () => {
      const query = r.table('test');
      const filters = { name: 'Darth Vader' };
      const result = rethinkdb.buildQuery(query, 'name', filters);
      const expected = query.getAll('Darth Vader', { index: 'name' });

      result.toString().must.equal(expected.toString());
    });

    it('must use an index when filters use an indexed property and .filter(x) any others', () => {
      const query = r.table('test');
      const filters = {
        name: 'Darth Vader',
        sith: true
      };
      const result = rethinkdb.buildQuery(query, 'name', filters);
      const expected = query.getAll('Darth Vader', { index: 'name' }).filter({ sith: true });

      result.toString().must.equal(expected.toString());
    });

    it('must use .get(x) when an id and no other params provided', () => {
      const query = r.table('test');
      const filters = { id: UUID };
      const result = rethinkdb.buildQuery(query, null, filters);
      const expected = query.get(UUID);

      result.toString().must.equal(expected.toString());
    });

    it('must use .filter(x) when an id and other params provided', () => {
      const query = r.table('test');
      const filters = { id: UUID, name: 'Luke Skywalker' };
      const result = rethinkdb.buildQuery(query, null, filters);
      const expected = query.filter(filters);

      result.toString().must.equal(expected.toString());
    });
  });

  describe('.addTransformations', () => {
    it('must apply .skip(x) when params contain skip', () => {
      const query = r.table('test');
      const params = { skip: 5 };
      const result = rethinkdb.addTransformations(query, [], params);

      const expected = query.skip(5);
      result.toString().must.equal(expected.toString());
    });

    it('must apply .limit(x) when params contain limit', () => {
      const query = r.table('test');
      const params = { limit: 5 };
      const result = rethinkdb.addTransformations(query, [], params);

      const expected = query.limit(5);
      result.toString().must.equal(expected.toString());
    });

    it('must apply .orderBy(x) when params contain orderBy and default to ascending', () => {
      const query = r.table('test');
      const params = { orderBy: 'name' };
      const result = rethinkdb.addTransformations(query, [], params);

      const expected = query.orderBy(r.asc('name'));
      result.toString().must.equal(expected.toString());
    });

    it('must apply sort order to orderBy when params contain order', () => {
      const query = r.table('test');
      const params = { orderBy: 'name', order: 'desc' };
      const result = rethinkdb.addTransformations(query, [], params);

      const expected = query.orderBy(r.desc('name'));
      result.toString().must.equal(expected.toString());
    });

    it('must apply an index to orderBy when using an indexed property', () => {
      const query = r.table('test');
      const params = { orderBy: 'name' };
      const result = rethinkdb.addTransformations(query, ['orderBy'], params);

      const expected = query.orderBy({ index: r.asc('name') });
      result.toString().must.equal(expected.toString());
    });

    it('must apply an index and sort order to orderBy when using an indexed property', () => {
      const query = r.table('test');
      const params = { orderBy: 'name', order: 'desc' };
      const result = rethinkdb.addTransformations(query, ['orderBy'], params);

      const expected = query.orderBy({ index: r.desc('name') });
      result.toString().must.equal(expected.toString());
    });
  });

  describe('.isChangeFeedable', () => {
    it('must return false when given a query using orderBy without limit', () => {
      const table = r.table('test');
      const query = table.orderBy('name');

      const result = rethinkdb.isChangeFeedable(query);
      result.must.equal(result, false);
    });

    it('must return false when given a query using limit without orderBy', () => {
      const table = r.table('test');
      const query = table.limit(1);

      const result = rethinkdb.isChangeFeedable(query);
      result.must.equal(result, false);
    });

    // this issue is not documented but causes the same problem as limit without orderBy
    it('must return false when given a query using skip without orderBy', () => {
      const table = r.table('test');
      const query = table.skip(1);

      const result = rethinkdb.isChangeFeedable(query);
      result.must.equal(false);
    });

    it('must return false when given a query using orderBy without an index', () => {
      const table = r.table('test');
      const query = table.limit(1).orderBy('name');

      const result = rethinkdb.isChangeFeedable(query);
      result.must.equal(false);
    });

    it('must return true when given a query using orderBy with an index', () => {
      const table = r.table('test');

      const query = table.limit(1).orderBy({ index: 'name' });
      const result = rethinkdb.isChangeFeedable(query);
      result.must.equal(true);

      const query2 = table.limit(1).orderBy({ index: r.desc('date') });
      const result2 = rethinkdb.isChangeFeedable(query2);
      result2.must.equal(true);
    });

    it('must return true when given a filter before limit and orderBy', () => {
      const table = r.table('test');

      const query = table.filter({ name: 'Darh Vader' }).limit(1).orderBy({ index: 'name' });
      const result = rethinkdb.isChangeFeedable(query);
      result.must.equal(true);
    });

    it('must return false when given a filter after limit and orderBy', () => {
      const table = r.table('test');

      const query = table.limit(1).orderBy({ index: 'name' }).filter({ name: 'Darh Vader' });
      const result = rethinkdb.isChangeFeedable(query);
      result.must.equal(false);
    });
  });
});
